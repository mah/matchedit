#!/usr/bin/perl
# TODO option to read file names from STDIN
# TODO perlify it - no more egrep dependencies...
use File::Temp qw(tempfile);
use Getopt::Long;
use Pod::Usage;

GetOptions(\%options, qw( C|context=i editor=s help|h|? )) or pod2usage(2);
pod2usage(1) if $options{help};
$options{C} ||= 2;
$options{editor} ||= $ENV{EDITOR} || 'vim';
pod2usage "?Argument to --context must not be negative." if $options{C} < 0;
$re = quotemeta shift @ARGV or pod2usage "?Missing regular expression.";
pod2usage "?Missing file names." unless @ARGV;
# possibly: @ARGV = glob("*") unless @ARGV;
# possibly: @ARGV = grep { -f && -T } @ARGV;

$FILE = "";
open( IF, "egrep -C $options{C} -d skip -n -Z $re @ARGV /|" );
	# the '/' at the end forces my grep to prefix filenames even on single file input
	# the '-d skip' causes egrep to silently ignore the directory
	# the -Z option causes filenames to be terminated by \0 which simplifies parsing

die "?Could not match anything." if eof( IF );

$edits = ".matchedit-$$";
open( OF, ">$edits" );
while( <IF> ) {
	last unless m/^(.*?)\0(\d+?)[:-](.*)/;
	$fn = $1;
	$from = $to = $2;
	$line = "$3\n";
	if( $FILE eq "" ) {
		print OF "FILE $fn\n"
	} else {
		print OF "FILEEND\nFILE $fn\n" unless $fn eq $FILE;
	}
	$FILE = $fn;
	while( <IF> ) {
		last if /^--/;
		$to++;
		m/^.*?\0\d+[:-](.*)/;
		$line .= "$1\n";
	}
	print OF "LINES $from-$to\n${line}LINESEND\n";
}
print OF "FILEEND\n" unless $FILE eq "";
close IF; close OF;

system $options{editor}, $edits;

print "Answer YES if you want the changes to take effect: ";
$choice = <STDIN>;

if( $choice eq "YES\n" ) {
	open( IF, "<$edits" );
	while( <IF> ) {
		last unless m/^FILE (.*)/;
		$fn = $1;
		system( "mv $fn ${fn}.bak" );
		open( PROCIF, "<${fn}.bak" );
		open( OF, ">$fn" );
		while( <IF> ) {
			last unless m/^LINES (\d+)-(\d+)/;
			$from = $1;
			$to = $2;
			tell PROCIF;	# to initialize $.
			while( $. < $from - 1 ) {	# copy part before
				print OF scalar <PROCIF>;
			}
			while( $. < $to ) {	# dummy read the part
				<PROCIF>; 
			}
			while( <IF> ) { 	# paste in new lines
				last if /^LINESEND/; 
				print OF $_;
			}
			last if /^FILEEND/;
		}
# must have read FILEEND on correct file structure
		print OF <PROCIF>;	# copy rest of file

		close PROCIF;
	}
}

unlink $edits;

__END__
=head1 NAME

matchedit - edit regions of files that match a regular expression

=head1 SYNOPSIS

B<matchedit>
[B<--context> I<num>]
[B<--editor> I<editor>]
I<regexp>
I<file>...

=head1 DESCRIPTION

B<matchedit> allows you to edit the regions of the specified files that match the regular expression I<regexp>.

=head1 OPTIONS

=over 4

=item B<--context> I<num>, B<-C> I<num>

Print I<num> lines of context before and after each match.

=item B<--editor> I<editor>

Use I<editor> to edit the matches.
If this option is not given the editor defaults to the one specified with environment variable I<EDITOR> or vim.

=back

=head1 COPYRIGHT

(C) 2000-2005 Mark Hillebrand <mah at cs.uni-sb.de>.

This code is released under the BSD License.
Before using this software, visit L<http://www.opensource.org/licenses/bsd-license.php> for the full license text.
